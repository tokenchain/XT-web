<script type="text/x-template" id="vertical-scrollbar">
  <div>
    <div v-if="height < 100" class="vue-scrollbar__scrollbar-vertical" ref="container" @click="jump">
      <div :class="'scrollbar' + ( dragging || draggingFromParent ? '' : ' vue-scrollbar-transition')" ref="scrollbar" @touchstart="startDrag" @mousedown="startDrag " :style="{ height: height+'%', top: scrolling + '%' }">
      </div>
    </div>
  </div>
</script>

<script type="text/x-template" id="vue-scrollbar">
  <div @click="calculateSize" :class="'vue-scrollbar__wrapper' + ( this.classes ? ' ' + this.classes : '' )" ref="scrollWrapper" :style="this.styles">

    <div :class="'vue-scrollbar__area' + ( this.dragging ? ' ' : ' vue-scrollbar-transition')" ref="scrollArea" @wheel="scroll" @touchstart="startDrag" @touchmove="onDrag" @touchend="stopDrag" :style="{ marginTop: this.top * -1 +'px', marginLeft: this.left * -1 +'px' }">
      <slot></slot>
      <vertical-scrollbar
              v-if="ready"
              :area="{ height: scrollAreaHeight }"
              :wrapper="{ height: scrollWrapperHeight }"
              :scrolling="vMovement"
              :dragging-from-parent="dragging"
              :on-change-position="handleChangePosition"
              :on-dragging="handleScrollbarDragging"
              :on-stop-drag="handleScrollbarStopDrag" >
      </vertical-scrollbar>
    </div>

  </div>
</script>

<script>
  /***********
   **Vue 滚动条组件
   ************/
  require(['vue'], function (Vue){
    Vue.component('vue-scrollbar', {
      template: "#vue-scrollbar",
      props: {
        classes: String,
        styles: Object,
        speed: {
          type: Number,
          default: 53
        },
        onMaxScroll: Function
      },
      data: function() {
        return {
          ready: false,
          top: 0,
          left: 0,
          scrollAreaHeight: null,
          scrollAreaWidth: null,
          scrollWrapperHeight: null,
          scrollWrapperWidth: null,
          vMovement: 0,
          hMovement: 0,
          dragging: false,
          start: { y: 0, x: 0},
          allowBodyScroll: false
        }
      },
      methods: {
        calculateSize: function(cb){
          if(typeof cb !== 'function') cb = null;
          var elementSize = this.getSize();
          if (elementSize.scrollAreaHeight < elementSize.scrollWrapperHeight) {
            this.scrollToY(0);
          }
          if( elementSize.scrollWrapperHeight !== this.scrollWrapperHeight ||
              elementSize.scrollWrapperWidth !== this.scrollWrapperWidth ||
              elementSize.scrollAreaHeight !== this.scrollAreaHeight ||
              elementSize.scrollAreaWidth !== this.scrollAreaWidth )
          {
            // Scroll Area Height and Width
            this.scrollAreaHeight = elementSize.scrollAreaHeight;
            this.scrollAreaWidth = elementSize.scrollAreaWidth;
            // Scroll Wrapper Height and Width
            this.scrollWrapperHeight = elementSize.scrollWrapperHeight;
            this.scrollWrapperWidth = elementSize.scrollWrapperWidth;
            // Make sure The wrapper is Ready, then render the scrollbar
            this.ready = true;
            return cb ? cb() : false
          }
          else return cb ? cb() : false
        },
        getSize: function (){
          // The Elements
          var $scrollArea = this.$refs.scrollArea;
          var $scrollWrapper = this.$refs.scrollWrapper;

          // Get new Elements Size
          var elementSize = {
            // Scroll Area Height and Width
            scrollAreaHeight: $scrollArea.children[0].clientHeight,
            scrollAreaWidth: $scrollArea.children[0].clientWidth,
            // Scroll Wrapper Height and Width
            scrollWrapperHeight: $scrollWrapper.clientHeight,
            scrollWrapperWidth: $scrollWrapper.clientWidth,
          };
          //console.log(elementSize);
          return elementSize
        },
        scroll: function(e){
          // Make sure the content height is not changed
          this.calculateSize(function(){
            // Set the wheel step
            var num = this.speed;
            // DOM events
            var shifted = e.shiftKey;
            var scrollY = e.deltaY > 0 ? num : -(num);
            var scrollX = e.deltaX > 0 ? num : -(num);
            // Fix Mozilla Shifted Wheel~
            if(shifted && e.deltaX == 0) scrollX = e.deltaY > 0 ? num : -(num);
            // Next Value
            var nextY = this.top + scrollY;
            var nextX = this.left + scrollX;
            // Is it Scrollable?
            var canScrollY = this.scrollAreaHeight > this.scrollWrapperHeight;
            var canScrollX = this.scrollAreaWidth > this.scrollWrapperWidth;
            // Vertical Scrolling
            if(canScrollY && !shifted) this.normalizeVertical(nextY);
            // Horizontal Scrolling
            if(shifted && canScrollX) this.normalizeHorizontal(nextX)
          }.bind(this));
          // prevent Default only if scrolled content is not at the top/bottom
          if (!this.allowBodyScroll) {
            e.preventDefault();
            e.stopPropagation()
          }
        },
        // DRAG EVENT JUST FOR TOUCH DEVICE~
        startDrag: function(e){
          this.touchEvent = e;
          var evt = e.changedTouches ? e.changedTouches[0] : e;
          // Make sure the content height is not changed
          this.calculateSize(function() {
            // Prepare to drag
            this.dragging = true;
            this.start = { y: evt.pageY, x: evt.pageX }
          })
        },
        onDrag: function(e) {
          if(this.dragging){
            e.preventDefault();
            e.stopPropagation();
            // Prevent Click Event When it dragging
            if (this.touchEvent) {
              this.touchEvent.preventDefault();
              this.touchEvent.stopPropagation();
            }
            var evt = e.changedTouches ? e.changedTouches[0] : e;
            // Invers the Movement
            var yMovement = this.start.y - evt.clientY;
            var xMovement = this.start.x - evt.clientX;
            // Update the last e.client
            this.start = { y: evt.clientY, x: evt.clientX };
            // The next Vertical Value will be
            var nextY = this.top + yMovement;
            var nextX = this.left + xMovement;
            this.normalizeVertical(nextY);
            this.normalizeHorizontal(nextX)
          }
        },
        stopDrag: function(e){
          this.dragging = false;
          this.touchEvent = false
        },
        scrollToY: function(y) {
          this.normalizeVertical(y)
        },
        scrollToX: function(x) {
          this.normalizeHorizontal(x)
        },
        normalizeVertical: function(next){
          var elementSize = this.getSize();
          // Vertical Scrolling
          var lowerEnd = elementSize.scrollAreaHeight - elementSize.scrollWrapperHeight;
          // Max Scroll Down
          var maxBottom = next > lowerEnd;
          if(maxBottom) next = lowerEnd;
          // Max Scroll Up
          var maxTop = next < 0;
          if(maxTop) next = 0;
          // Update the Vertical Value if it's needed
          var shouldScroll = this.top !== next;
          this.allowBodyScroll = !shouldScroll;
          if (shouldScroll) {
            this.top = next;
            this.vMovement = next / elementSize.scrollAreaHeight * 100;
            if (this.onMaxScroll && (maxTop || maxBottom)) {
              this.onMaxScroll({ top: maxTop, bottom: maxBottom, right: false, left: false })
            }
          }
        },
        handleChangePosition: function(movement, orientation){
          // Make sure the content height is not changed
          this.calculateSize(function() {
            // Convert Percentage to Pixel
            var next = movement / 100;
            if( orientation == 'vertical' ) this.normalizeVertical( next * this.scrollAreaHeight );
            //if( orientation == 'horizontal' ) this.normalizeHorizontal( next * this.scrollAreaWidth )
          }.bind(this))
        },
        handleScrollbarDragging: function(){
          this.dragging = true
        },
        handleScrollbarStopDrag: function(){
          this.dragging = false
        }
      },
      mounted: function() {
        this.calculateSize();
        // Attach The Event for Responsive View~
        window.addEventListener('resize', this.calculateSize)
      },
      beforeDestroy: function(){
        // Remove Event
        window.removeEventListener('resize', this.calculateSize)
      }
    });

    Vue.component('vertical-scrollbar', {
      template: "#vertical-scrollbar",
      props: {
        draggingFromParent: Boolean,
        scrolling: Number,
        wrapper: Object,
        area: Object,
        onChangePosition: Function,
        onDragging: Function,
        onStopDrag: Function
      },
      data: function () {
        return {
          height: 0,
          dragging: false,
          start: 0
        }
      },
      watch: {
        'wrapper.height': function(val, old) {
          this.calculateSize(this)
        },
        'area.height': function(val, old) {
          this.calculateSize(this)
        }
      },
      methods: {
        calculateSize: function(source){
          // Scrollbar Height
          this.height = source.wrapper.height / source.area.height * 100
        },
        getSize: function(){
          // The Elements
          var $scrollArea = this.$refs.container.parentElement;
          var $scrollWrapper = $scrollArea.parentElement;
          // Get new Elements Size
          var elementSize = {
            // Scroll Area Height and Width
            scrollAreaHeight: $scrollArea.children[0].clientHeight,
            scrollAreaWidth: $scrollArea.children[0].clientWidth,
            // Scroll Wrapper Height and Width
            scrollWrapperHeight: $scrollWrapper.clientHeight,
            scrollWrapperWidth: $scrollWrapper.clientWidth
          };
          return elementSize
        },
        startDrag: function(e){
          e.preventDefault();
          e.stopPropagation();
          e = e.changedTouches ? e.changedTouches[0] : e;
          // Prepare to drag
          this.dragging = true;
          this.start = e.clientY
        },
        onDrag: function(e){
          if(this.dragging){
            // Make The Parent being in the Dragging State
            this.onDragging();
            e.preventDefault();
            e.stopPropagation();
            e = e.changedTouches ? e.changedTouches[0] : e;
            var yMovement = e.clientY - this.start;
            var yMovementPercentage = yMovement / this.wrapper.height * 100;
            // Update the last e.clientY
            this.start = e.clientY;
            // The next Vertical Value will be
            var next = this.scrolling + yMovementPercentage;
            // Tell the parent to change the position
            this.onChangePosition(next, 'vertical')
          }
        },
        stopDrag: function(e){
          if(this.dragging){
            // Parent Should Change the Dragging State
            this.onStopDrag();
            this.dragging = false
          }
        },
        jump: function(e){
          var isContainer = e.target === this.$refs.container;
          if(isContainer){
            // Get the Element Position
            var position = this.$refs.scrollbar.getBoundingClientRect();
            // Calculate the vertical Movement
            var yMovement = e.clientY - position.top;
            var centerize = (this.height / 2);
            var yMovementPercentage = yMovement / this.wrapper.height * 100 - centerize;
            // Update the last e.clientY
            this.start = e.clientY;
            // The next Vertical Value will be
            var next = this.scrolling + yMovementPercentage;
            // Tell the parent to change the position
            this.onChangePosition(next, 'vertical')
          }
        }


      },
      mounted: function() {
        this.calculateSize(this);
        // Put the Listener
        document.addEventListener("mousemove", this.onDrag);
        document.addEventListener("touchmove", this.onDrag);
        document.addEventListener("mouseup", this.stopDrag);
        document.addEventListener("touchend", this.stopDrag)
      },
      beforeUpdate: function() {
      },
      beforeDestroy: function() {
        document.removeEventListener("mousemove", this.onDrag);
        document.removeEventListener("touchmove", this.onDrag);
        document.removeEventListener("mouseup", this.stopDrag);
        document.removeEventListener("touchend", this.stopDrag)
      }
    })

  })

</script>
